# -*- coding: utf-8 -*-
"""rule_parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XCkalfULOul8e8kgBP7r6P8ybszB5Edy
"""

# parsers/rule_parser.py

import re
from typing import Dict, List

class RuleParser:
    """Rule-based parser for drilling workover data"""

    def parse_row(self, row: str) -> Dict:
        """Parse a single row using rule-based approach"""

        # Extract times
        waktu_mulai, waktu_akhir = self._extract_times(row)

        # Extract duration
        durasi_jam = self._extract_duration(row)

        # Extract other components
        parts = self._split_row_parts(row)

        # Determine which part is which
        equipment, depth, condition = self._classify_parts(parts)

        return {
            "waktu_mulai": waktu_mulai,
            "waktu_akhir": waktu_akhir,
            "durasi_jam": durasi_jam,
            "peralatan_deskripsi": equipment,
            "interval_kedalaman": depth,
            "kondisi_hasil": condition
        }

    def _extract_times(self, row: str) -> tuple:
        """Extract start and end times"""
        time_pattern = r'(\d{1,2}:\d{2})'
        times = re.findall(time_pattern, row)

        waktu_mulai = times[0] if len(times) > 0 else "N/A"
        waktu_akhir = times[1] if len(times) > 1 else "N/A"

        return waktu_mulai, waktu_akhir

    def _extract_duration(self, row: str) -> float:
        """Extract duration in hours"""
        # Try explicit duration pattern
        duration_pattern = r'(\d+\.?\d*)\s*(?:Jam|jam|hours?|hrs?)'
        duration_match = re.search(duration_pattern, row)

        if duration_match:
            return float(duration_match.group(1))

        # Try to find any decimal number
        dec_pattern = r'\b(\d+\.\d+)\b'
        dec_match = re.search(dec_pattern, row)

        return float(dec_match.group(1)) if dec_match else 0.0

    def _split_row_parts(self, row: str) -> List[str]:
        """Split row into logical parts"""
        # Try splitting by multiple spaces first
        parts = re.split(r'\s{2,}', row)

        if len(parts) >= 6:
            return parts

        # If not enough parts, try alternative splitting
        return row.split()

    def _classify_parts(self, parts: List[str]) -> tuple:
        """Classify parts into equipment, depth, and condition"""
        equipment_keywords = ['BAILING', 'M/U', 'RIH', 'POH', 'SWAB', 'N/U', 'N/D', 'LOWER', 'W/O']
        equipment_parts = []
        depth_parts = []
        condition_parts = []

        for part in parts:
            if any(kw.lower() in part.lower() for kw in equipment_keywords):
                equipment_parts.append(part)
            elif any(ind in part for ind in ['F/', '@', 'TO', '-', "'", 'FT', 'INTVL']):
                depth_parts.append(part)
            else:
                condition_parts.append(part)

        equipment = ' '.join(equipment_parts) if equipment_parts else "N/A"
        depth = ' '.join(depth_parts) if depth_parts else "N/A"
        condition = ' '.join(condition_parts) if condition_parts else "N/A"

        return equipment, depth, condition